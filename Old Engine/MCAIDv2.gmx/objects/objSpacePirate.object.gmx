<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_space_pirate</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>4</depth>
  <persistent>0</persistent>
  <parentName>PirateParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hiddenfade = 0;
if collision_point(x,y,objHideMap,true,true)
{
   if hiddenfade&lt;0 {hiddenfade=0}
   hiddenfade+=.05
   if hiddenfade&gt;1 {hiddenfade=1}
}
else
{
   if hiddenfade&gt;1 {hiddenfade=1}
   hiddenfade-=.05
   if hiddenfade&lt;0 {hiddenfade=0}
}

//standard variables
en_default=4;
en=en_default;
damage=false;
s = true;
justfroze = false;
image_speed = .3;
ItemVars();
size=max(sprite_width,sprite_height)

type_patrol=1;
type_attack=2;
type_defend=3;
type_default=type_patrol;
type=type_default;

state_wait=101;
state_patrol=102;
state_search=103;
state_chase=104;
state_attack=105;
state_follow=106;
state_reset=107;
state_wander=108;
state_default=state_patrol;
state=state_patrol;

sub_state_move=201;
sub_state_stand=202;
sub_state_fire=203;
sub_state_strafe=204;
sub_state_death=205;
sub_state_default=sub_state_stand;
sub_state=sub_state_default;

move_target_x=x;
move_target_y=y;
last_target_x=x;
last_target_y=y;
informed_x=x; 
informed_y=y;
target_movement_direction=0

bad_x=0
bad_y=0


// Path Finding
path_reset_x=ds_stack_create();
path_reset_y=ds_stack_create();
ds_stack_push(path_reset_x,xstart);
ds_stack_push(path_reset_y,ystart);

// timers and triggers
timer=0;
state_timer=0;
state_change=true;
sub_state_timer=0;
sub_state_change=false;
sight = 0;
sight_timer=0
stuck=0;
sprite_timer=0;
push=false;

// local stuff
fire_hand=1;
face_direction=0;
move_direction=0;
sight_angle=0
informed=0
adrenaline=0

//  per type constants
listen_range=60;
max_speed=1.5;
temp_speed = 0.75;

// Per Unit Constants
fav_direction=choose(-90,90);
fav_long_range=400-abs(Gauss(100,75))
fav_close_range=200-abs(Gauss(0,100))
offensive_bias=Gauss(.5,.5)

move_target_distance=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_stack_destroy(path_reset_x);
ds_stack_destroy(path_reset_y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.highest!=id) exit;
global.highest=0;
if (global.spacepiratescanned) then
{
   with (instance_create(0,0,messageGenScan)) 
   {
       text = "Space Pirates have been present since the early days of the Galactic Federation. They quickly established themselves as a fearsome force, necessitating the formation of the Galactic Federation Police. The Pirates were notorious for attacking and raiding vessels in one second, and disappearing the next. The Pirates would also lay claim to planets, establishing the now-captured planet as their territory and its natives as their slaves. They were known to be so zealous of their right to rule that they would even refer to themselves as the rightful inhabitants of the planet, taking on the name of the race of the former inhabitants and referring to the true natives as their slaves. The Pirates have been responsible for some of the most disastrous events in galactic history, such as the Phazon Crisis, and have been responsible for the raids of numerous planets, including Zebes, Bryyo, Norion, Elysia, Tallon IV, Aether, Dark Aether, Naishii, Jigrad, and K-2L. An important trait of the Space Pirates is that they are known to tamper with their own genome. They have evolved countless times, and there are many different types to encounter, making it difficult to counter their tactics and prepare for any assault.##This pirate is a conventional foot-soldier type. They possess only a moderately-effective weapon known as the Clawshot. These pirates tend to be the pawns of the Pirate army. Easily dispatched, but be wary of their speed, intelligence, tracking abilities, and firepower.";
   }
}
if (!global.spacepiratescanned) then
{
   sound_play(DataRec);
   global.spacepiratescanned = true;
   with (instance_create(0,0,messageGenScan)) 
   {
       text = "- Morphology entry added. -##Space Pirates have been present since the early days of the Galactic Federation. They quickly established themselves as a fearsome force, necessitating the formation of the Galactic Federation Police. The Pirates were notorious for attacking and raiding vessels in one second, and disappearing the next. The Pirates would also lay claim to planets, establishing the now-captured planet as their territory and its natives as their slaves. They were known to be so zealous of their right to rule that they would even refer to themselves as the rightful inhabitants of the planet, taking on the name of the race of the former inhabitants and referring to the true natives as their slaves. The Pirates have been responsible for some of the most disastrous events in galactic history, such as the Phazon Crisis, and have been responsible for the raids of numerous planets, including Zebes, Bryyo, Norion, Elysia, Tallon IV, Aether, Dark Aether, Naishii, Jigrad, and K-2L. An important trait of the Space Pirates is that they are known to tamper with their own genome. They have evolved countless times, and there are many different types to encounter, making it difficult to counter their tactics and prepare for any assault.##This pirate is a conventional foot-soldier type. They possess only a moderately-effective weapon known as the Clawshot. These pirates tend to be the pawns of the Pirate army. Easily dispatched, but be wary of their speed, intelligence, tracking abilities, and firepower.";
   }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
if collision_point(x,y,objHideMap,true,true)
{
   if hiddenfade&lt;0 {hiddenfade=0}
   hiddenfade+=.05
   if hiddenfade&gt;1 {hiddenfade=1}
}
else
{
   if hiddenfade&gt;1 {hiddenfade=1}
   hiddenfade-=.05
   if hiddenfade&lt;0 {hiddenfade=0}
}
*/
LightCircle(x,y,global.range/2,.5);
LightCircle(x,y,global.range-10,.1);
RevealCircle(x,y,global.range/2,.6*global.hiddenfade);
RevealCircle(x,y,global.range/3-15,global.hiddenfade);
face_direction=image_angle
if (!push) {speed=temp_speed}
// find return path node
if (state != state_reset)
   {
   if (collision_line(x,y,xstart,ystart,BlockParent,true,true)&lt;=0)
      {ds_stack_clear(path_reset_x);ds_stack_push(path_reset_x,xstart);ds_stack_clear(path_reset_y);ds_stack_push(path_reset_y,ystart);}
   if (collision_line(x,y,ds_stack_top(path_reset_x),ds_stack_top(path_reset_y),BlockParent,true,true))
      {
      ds_stack_push(path_reset_x,x);
      ds_stack_push(path_reset_y,y);
      }
   }



//
if (sight)
   {
   if instance_exists(objPlayer)
      {
      target_movement_direction=point_direction(target.xprevious,target.yprevious,target.x,target.y)
      target_movement_speed=point_distance(target.xprevious,target.yprevious,target.x,target.y)
      }
   }
//



// detects if walking into a wall. works pretty well.
if state_change=true {stuck=0}  
stuck=min(max(0,stuck-1),stuck+1)
if (point_distance(xprevious,yprevious,x,y)&lt;.9) {stuck+=4}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// resets
push=false
maxs=max_speed;
sight=false;
delta_face_direction=0
// misc
informed-=1;
adrenaline=max(sqr(en_default-en),min(100,adrenaline-.2));
// clock functions
timer-=1;
sprite_timer+=1;
state_timer-=1;
sub_state_timer-=1;
//
fav_direction=-90

//Brain functions
if instance_exists(objPlayer)
   {target=instance_nearest(x,y,objPlayer)}
else {target=instance_furthest(x,y,objCursorController)}
sightline=(0&gt;collision_line(x,y,target.x,target.y,BlockParent,true,true));
range=distance_to_object(target);
target_direction=point_direction(x,y,last_target_x,last_target_y);
target_distance=point_distance(x,y,last_target_x,last_target_y);
vision_angle=abs(AngleDifference(face_direction,point_direction(x,y,target.x,target.y)));

if (sightline &amp;&amp;  vision_angle &lt; 91)or (sightline &amp;&amp; range&lt;listen_range){sight=true}
if (sight=true)
   {
   last_target_x=target.x;
   last_target_y=target.y;
   sight_timer=max(sight_timer+1,0)
   target_movement_direction=point_direction(target.xprevious,target.yprevious,target.x,target.y)
   target_movement_speed=point_distance(target.xprevious,target.yprevious,target.x,target.y)
   sight_angle=AngleDifference(target_direction,face_direction)
   with objSpacePirate // Communicates target location to other nearby pirates.
        {
        if ( (collision_line(x,y,other.x,other.y,BlockParent,true,true)&lt;=0) and sight_timer&lt;0 )
           {
           state_change=true; 
           state=state_follow;
           if (collision_line(x,y,(other.x+target.x)/2,(other.y+target.y)/2,BlockParent,true,true))
              {informed_x=other.x; informed_y=other.y;}
              else
              {informed_x=(other.x+target.x)/2; informed_y=(other.y+target.y)/2;informed=10}
           last_target_x=target.x;
           last_target_y=target.y;
           target_movement_direction=point_direction(target.xprevious,target.yprevious,target.x,target.y)
           target_movement_speed=point_distance(target.xprevious,target.yprevious,target.x,target.y)
           }
        }
   }
   else
       {
       sight_timer=min(sight_timer-1,0)
       if ((informed&lt;=0) &amp;&amp; instance_exists(ALLWEAPParent))
          {
          bullets=ds_priority_create()
          with ALLWEAPParent
               {
               if image_alpha&lt;.5 {continue}
               if speed=0 {continue}
               if (abs(AngleDifference(point_direction(other.x,other.y,x,y),other.face_direction))&gt;91 
               and point_distance(x,y,other.x,other.y)&gt;other.listen_range) 
                  {continue}
               if (collision_line(x,y,other.x,other.y,BlockParent,true,true)&lt;=0)
                  {
                  ds_priority_add(other.bullets,id,age)
                  }
               }
          
          if (ds_priority_size(bullets))
             {
             state_change=true; 
             state=state_follow;
             freshest_weapon=ds_priority_find_min(bullets);
             last_target_x=freshest_weapon.x;
             last_target_y=freshest_weapon.y;
             informed_x=freshest_weapon.x;
             informed_y=freshest_weapon.y;
             with freshest_weapon
                {
                
                //if object_index=objHomingMissile {continue}
                var factor,px,py,xx,yy;
                xx=y;
                yy=x;
                factor=.5
                repeat 4
                   {
                   px=x-hspeed*age*factor
                   py=y-vspeed*age*factor
                   if (collision_line(px,py,other.x,other.y,BlockParent,true,true)&lt;=0)
                      {factor+=.5*factor;xx=px;yy=py;}
                   else
                      {factor-=.5*factor}
                   }
                }
                target_movement_direction=freshest_weapon.direction+180
             last_target_x=xx;
             last_target_y=yy;
             informed_x=xx;
             informed_y=yy;
             informed=true;
             
             }
          ds_priority_destroy(bullets);
          
          }
       
          
       
       
       
       
       if ((informed&lt;=0) &amp;&amp; instance_exists(objPlayerFootstep))
          {
          footprints=ds_priority_create()
          with objPlayerFootstep
               { 
               if timer&lt;-30 {continue;}
               if abs(AngleDifference(point_direction(other.x,other.y,x,y),other.face_direction))&gt;91 {continue}
               if (collision_line(x,y,other.x,other.y,BlockParent,true,true)&lt;=0)
                  {
                  ds_priority_add(other.footprints,id,timer)
                  }
               }
          
          if (ds_priority_size(footprints))
             {
             state_change=true; 
             state=state_follow;
             freshest_footprint=ds_priority_find_max(footprints);
             last_target_x=freshest_footprint.x;
             last_target_y=freshest_footprint.y;
             informed_x=freshest_footprint.x;
             informed_y=freshest_footprint.y;
             }
          ds_priority_destroy(footprints);
          
          }
       }




if type=type_patrol
   {
   switch state
          {
//----------------//     
          case state_wait:
               //initialize
               if state_change
                  {
                  if state_change=state_wander
                     {state_change=state_wander-1;}
                     else
                     {state_change=false;}
                  if state_change!=state_wander-1
                     {
                     sub_state_timer=state_timer;
                     state_timer=32;
                     }
                  }
               //state code
               sub_state=sub_state_stand;
               if state_timer &gt;= 24 {delta_face_direction=fav_direction/8}
               if (24&gt;state_timer &amp;&amp; state_timer&gt;=8) {delta_face_direction=fav_direction/-8}
               if 8&gt; state_timer {delta_face_direction=fav_direction/8}
             //state change
             if (state_timer=0 and state_change=state_wander-1) {state=state_wander;}
             if state_timer=0 {state=state_search;state_timer=sub_state_timer+32;}
             if (sight) {state_change=true; state=state_chase}
          break;
//----------------//     
          case state_patrol:
               //initialize
               if (state_change)
                  { state_change=false
                  wide=range_finder(x,y,0,2000,BlockParent,true,true)+range_finder(x,y,180,2000,BlockParent,true,true)
                  tall=range_finder(x,y,90,2000,BlockParent,true,true)+range_finder(x,y,270,2000,BlockParent,true,true)
                  if wide &gt; tall {move_direction=choose(0,180)} else {move_direction=choose(90,270)}
                  }
               //state code   
               sub_state=sub_state_move;
               maxs-=1.5
               move_target_x=x+4*size*lengthdir_x( maxs, move_direction )
               move_target_y=y+4*size*lengthdir_y( maxs, move_direction )
               if (stuck&gt;12) {move_direction+=fav_direction*2;stuck=-20}
            //state change
            if (sight) {state_change=true; state=state_chase}
          break;
//----------------//          
          case state_search:
               //initialize
               if (state_change)
                  { state_change=false
                  if !(state_timer=sub_state_timer+32) {state_timer=offensive_bias*1200+adrenaline}
                  stuck=0
                  right=range_finder(x,y,0,400,BlockParent,true,true)
                  if right=-1 {right=3000+random(5)}
                  left=range_finder(x,y,180,400,BlockParent,true,true)
                  if left=-1 {left=3000+random(5)}
                  up=range_finder(x,y,90,400,BlockParent,true,true)
                  if up=-1 {up=3000+random(5)}
                  down=range_finder(x,y,270,400,BlockParent,true,true)
                  if down=-1 {right=3000+random(5)}
                  switch max(right,left,up,down)
                         {
                         case right: move_direction=0;; break;
                         case left: move_direction=180;; break;
                         case up: move_direction=90;; break;
                         case down: move_direction=270;; break;
                         }
                  }
               //state code   
               sub_state=sub_state_move;
               maxs-=1
               move_target_x=x+4*size*lengthdir_x( maxs, move_direction )
               move_target_y=y+4*size*lengthdir_y( maxs, move_direction )
               if (stuck&gt;12) {move_direction+=fav_direction*sign(random(100)-15);stuck=-15}
            //state change
            if ((timer mod 90+floor(random(20)))=0) {state_change=true; state=state_wait}
            if state_timer&lt;=0 {state_change=true; state=state_reset;}
            if (sight) {state_change=true; state=state_chase}
            //if timer&gt;=800 {state_change=true; state=state_reset;}
          break;
//----------------//   
          case state_chase:
               //initialize
               if (state_change)
                  {state_change=false;
                  state_timer=10+floor(random(30));
                  }
               //state code
               sub_state=sub_state_move
               move_target_x=last_target_x;
               move_target_y=last_target_y;
               //state change
               if (stuck &gt;10) {sub_state=sub_state_strafe;move_target_x=x+4*size*lengthdir_x( maxs, target_direction+fav_direction );move_target_y=y+4*size*lengthdir_y( maxs, target_direction+fav_direction ); }
               //if (stuck&gt;40) {fav_direction*=-1}
            if (stuck &gt; 80) {state_change=true; state=state_search}
            if (sight &amp;&amp; abs(sight_angle)&lt;20)
               {
               if (sight_timer&gt;15 &amp;&amp; target_distance&lt;fav_long_range &amp;&amp; state_timer&lt;5)
               or (sight_timer&gt;5 &amp;&amp; target_distance&lt;fav_close_range &amp;&amp; state_timer &lt;15)
               or (sight_timer&gt;3 &amp;&amp; target_distance&lt;100 &amp;&amp; state_timer &lt;30)
               or (sight_timer&gt;2 &amp;&amp; target_distance&lt;64)
                  {state_change=true;state=state_attack;}
               }
            if (move_target_distance=0) { state_change=true; state=state_wander; state_timer=0}
               
          break;
//----------------//   
          case state_attack:
               //initialize
               if (state_change=true)
                  { state_change=false
                  state_timer=30+floor(random(35));
                  sub_state=sub_state_fire;
                  sub_state_timer=choose(5,10,15)
                  }
               //state code   
               if (sub_state=sub_state_fire &amp;&amp; (13+sprite_timer mod 5)=13) 
                  {
                  var g;
                  g=Gauss(0,2);
                  repeat(2) {
                            fire_hand=-fire_hand
                            sound_play(PirateShot);
                            blast=instance_create( (x+9*cos(-face_direction/180*pi))+fire_hand*7*sin(face_direction/180*pi), (y+9*sin(-face_direction/180*pi))+fire_hand*7*cos(face_direction/180*pi),objPirateBlast);
                            with (blast) 
                                 {direction=other.face_direction+g; image_angle=direction; speed=9;}
                            }       
                  }
               if sub_state_timer&lt;=0 {sub_state=sub_state_strafe;if place_meeting(move_target_x,move_target_y,BlockParent){fav_direction*=-1}move_target_x=x+4*size*lengthdir_x( maxs, target_direction+fav_direction );move_target_y=y+4*size*lengthdir_y( maxs, target_direction+fav_direction ); }
            //state change
            if state_timer=0 {state_change=true;state=state_chase;}
          break;
//----------------//     
          case state_follow:
               //initialize
               if (state_change)
                  {state_change=false;
                  state_timer=400;
                  }
               //state code   
               sub_state=sub_state_strafe
               move_target_x=informed_x;
               move_target_y=informed_y;
            //state change
            //if (stuck &gt;10) {sub_state=sub_state_strafe;move_target_x=x+4*size*lengthdir_x( maxs, target_direction+fav_direction );move_target_y=y+4*size*lengthdir_y( maxs, target_direction+fav_direction ); }
            //if (stuck&gt;40) {fav_direction*=-1}
            if stuck&gt;80
            or (sight)
               {state_change=true;state=state_chase;}
            if (point_distance(informed_x,informed_y,x,y)&lt;(maxs+1) || state_timer=0) { state_change=true; state=state_chase }
          break;
//----------------//   
          case state_reset:
               //initialize
               if (state_change=true)
                  { state_change=false
                  state_timer=2000;
                  sub_state=sub_state_move;
                  }
               //state code   
               if (move_target_distance=0 and move_target_x=xstart and move_target_y=ystart) {state_change=true; state=state_patrol;continue;}
               if (move_target_distance=0) {sub_state_timer=100;bad_x=move_target_x;bad_y=move_target_y;locked_direction=move_direction}
               maxs-=1.5
               sub_state=sub_state_move
               temp_path_reset_x=ds_stack_create();
               ds_stack_copy(temp_path_reset_x,path_reset_x);
               temp_path_reset_y=ds_stack_create();
               ds_stack_copy(temp_path_reset_y,path_reset_y);
               var tempx, tempy;
               while ds_stack_size(temp_path_reset_x)
                     {
                     tempx=ds_stack_pop(temp_path_reset_x);
                     tempy=ds_stack_pop(temp_path_reset_y);
                     if (collision_line(x,y,tempx,tempy,BlockParent,true,true)=noone)
                        {
                        move_target_x=tempx;
                        move_target_y=tempy;
                        }
                     }
                     ds_stack_destroy(temp_path_reset_x);
                     ds_stack_destroy(temp_path_reset_y);
                     move_direction=point_direction(x,y,move_target_x,move_target_y)
                     if (move_target_x=bad_x and move_target_y=bad_y and sub_state_timer&gt;0)
                        {
                        move_target_x=x+4*size*lengthdir_x( maxs, locked_direction);
                        move_target_y=y+4*size*lengthdir_y( maxs, locked_direction);
                        }
                     
                     
            //state change
            if (move_target_distance=0 and move_target_x=xstart and move_target_y=ystart) {state_change=true; state=state_patrol;}
            if state_timer=0
            or (stuck&gt;30)
               {state_change=true;state=state_search;}
            if (sight)
               {state_change=true;state=state_chase;}
                  
          break;    
//----------------//    
          case state_wander:
               //initialize
               if (state_change)
                  { state_change=false
                  move_direction=target_movement_direction+Gauss(0,20);
                  state_timer=80+180*offensive_bias+adrenaline
                  }
               //state code
               sub_state=sub_state_move;
               move_target_x=x+4*size*lengthdir_x( maxs, move_direction )
               move_target_y=y+4*size*lengthdir_y( maxs, move_direction )
            //state change
            if 0&gt;=state_timer {state_change=true; state=state_wait; timer=0}
            if (stuck&gt;10) {state_change=state;state=state_wait;move_direction+=fav_direction*choose(1,.5);stuck=-15}
            if (sight) {state_change=true;state=state_chase;}
          break;
          }
                  
                  
   }
if (0 &gt;= en &amp;&amp; sub_state!=sub_state_death)
   {sub_state=sub_state_death;sprite_timer=0;state=sub_state_death;sprite_index=spr_space_pirate_death}
switch sub_state
       {
       case sub_state_stand:
       speed=max(0,speed-.5)
       break;

       case sub_state_move:
       delta_face_direction=median(-15,15,AngleDifference(point_direction(x,y,move_target_x,move_target_y),face_direction))
       motion_add(point_direction(x,y,move_target_x,move_target_y),.5)
       move_target_distance=distance_to_point(move_target_x,move_target_y)
       speed=min(speed,move_target_distance)
       break;
   
       case sub_state_fire:
       delta_face_direction=median(-15,15,AngleDifference(point_direction(x,y,last_target_x,last_target_y),face_direction))
       speed=max(0,speed-.5)
       break;
       
       case sub_state_strafe:
       delta_face_direction=median(-15,15,AngleDifference(point_direction(x,y,last_target_x,last_target_y),face_direction))
       motion_add(point_direction(x,y,move_target_x,move_target_y),1)
       break;
       
       case sub_state_death:
       repeat 3
          {
          if place_meeting(x,y,BlockParent)
             {x-=lengthdir_x(1,face_direction);y-=lengthdir_y(1,face_direction)}
          }
       speed=0
       if sprite_timer &gt;15 
       {
         a = instance_create(x,y,objDeadPirate);
         a.direction = image_angle;
         instance_destroy()}
       break;
       }
// end of step functions

if (true) {speed=min(speed,maxs)}
temp_speed=speed
move_step_ext(x+hspeed,y+vspeed,delta_face_direction,BlockParent)
speed=0

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="IceBeamParent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var a;
    
a = instance_create(x,y,objSpacePirateFrozen);
a.image_index = image_index;
a.image_angle = image_angle;
a.image_speed = 0;
a.hp = en;
a.hiddenfade = hiddenfade;

justfroze = true;
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ALLWEAPParent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (en &gt; 0)
{
   Damage();
   if (collision_line(x,y,other.x,other.y,BlockParent,1,0)) exit;
   if (s) then
   {
      if (en &gt; 0) sound_play(PirateHit);
      s = false;
      alarm[0] = random(10)+5;
   }
   if (en &lt;= 0) 
      { if (justfroze = false) SpawnItem(); sound_play(PirateDie); }
   damage = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objSpacePirate">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (push=false)
   {
   push = true
   speed=temp_speed
   //direction=temp_direction
   }
motion_add(point_direction(other.x,other.y,x,y),.1); // keeps pirates from stacking on top of each other while still allowing them to walk paast each other in narrow areas.

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>MessageCheckDepth();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch sub_state
      {
      case sub_state_move:
      draw_sprite_ext(sprite_index,sprite_timer mod 12,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_stand:
      draw_sprite_ext(sprite_index,12,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_fire: 
      draw_sprite_ext(sprite_index,13+sprite_timer mod 5,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_strafe:
      draw_sprite_ext(sprite_index,sprite_timer mod 12,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_death:
      draw_sprite_ext(spr_space_pirate_death,sprite_timer,x,y,1,1,face_direction,c_white,1-.5*(sprite_timer=14)-.25*(sprite_timer=12))
      break;
      }
if damage=true
   {
   draw_set_blend_mode(bm_add);
   switch sub_state
      {
      case sub_state_move:
      draw_sprite_ext(sprite_index,sprite_timer mod 12,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_stand:
      draw_sprite_ext(sprite_index,12,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_fire: 
      draw_sprite_ext(sprite_index,13+sprite_timer mod 5,x,y,1,1,face_direction,c_white,1)
      break;
      
      case sub_state_strafe:
      draw_sprite_ext(sprite_index,sprite_timer mod 12,x,y,1,1,face_direction,c_white,1)
      break;
      
      //case sub_state_death:
      //draw_sprite_ext(spr_space_pirate_death,sprite_timer,x,y,1,1,face_direction,c_white,1-.5*(sprite_timer=14)-.25*(sprite_timer=12))
      //break;
      }
   draw_set_blend_mode(bm_normal);
   damage=false;
   } 
// enable this section for debug information
/*
if type=type_patrol
   {
   switch state
          {
          case state_wait:
          draw_text(x+32,y,'wait')
          break;
          
          case state_patrol:
          draw_text(x+32,y,'patrol')
          break;
          
          case state_search:
          draw_text(x+32,y,'search')
          break;
          
          case state_chase:
          draw_text(x+32,y,'chase')
               
          break;
          
          case state_attack:
          draw_text(x+32,y,'attack')
          break;
          
          case state_follow:
          draw_text(x+32,y,'follow')
          break;
          
          case state_reset:
          draw_text(x+32,y,'reset')
          break;
          
          case state_wander:
          draw_text(x+32,y,'wander')
          break;
          }
   }
draw_text(x+32,y+16,stuck)
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
